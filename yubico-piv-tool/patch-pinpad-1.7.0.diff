diff -urdN yubico-piv-tool-1.7.0/ykcs11/Makefile.am yubico-piv-tool-1.7.0.pinpad/ykcs11/Makefile.am
--- yubico-piv-tool-1.7.0/ykcs11/Makefile.am	2018-10-25 09:27:06.000000000 -0400
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/Makefile.am	2019-11-20 21:55:08.107514875 -0500
@@ -46,6 +46,7 @@
 libykcs11_la_SOURCES += objects.c objects.h obj_types.h
 libykcs11_la_SOURCES += pkcs11.h  pkcs11y.h
 libykcs11_la_SOURCES += ykcs11-version.h
+libykcs11_la_SOURCES += pinpad-osx.c pinpad-osx.h
 
 EXTRA_libykcs11_la_DEPENDENCIES = ykcs11.map
 
@@ -53,6 +54,7 @@
 libykcs11_la_LIBADD += ../tool/libpiv_util.la
 
 libykcs11_la_LDFLAGS = -no-undefined
+libykcs11_la_LDFLAGS += -framework CoreFoundation
 libykcs11_la_LDFLAGS += -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
 
 if HAVE_LD_VERSION_SCRIPT
diff -urdN yubico-piv-tool-1.7.0/ykcs11/Makefile.in yubico-piv-tool-1.7.0.pinpad/ykcs11/Makefile.in
--- yubico-piv-tool-1.7.0/ykcs11/Makefile.in	2019-04-03 03:53:50.000000000 -0400
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/Makefile.in	2019-11-20 21:56:19.406902388 -0500
@@ -167,7 +167,7 @@
 libykcs11_la_DEPENDENCIES = ../lib/libykpiv.la ../tool/libpiv_util.la
 am_libykcs11_la_OBJECTS = ykcs11.lo vendors.lo slot_vendors.lo \
 	token_vendors.lo mechanisms.lo yubico_slot.lo yubico_token.lo \
-	utils.lo openssl_utils.lo objects.lo
+	utils.lo openssl_utils.lo objects.lo pinpad-osx.lo
 libykcs11_la_OBJECTS = $(am_libykcs11_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -462,12 +462,12 @@
 	mechanisms.h yubico_slot.c yubico_slot.h yubico_token.c \
 	yubico_token.h utils.c utils.h openssl_utils.c openssl_utils.h \
 	openssl_types.h objects.c objects.h obj_types.h pkcs11.h \
-	pkcs11y.h ykcs11-version.h
+	pkcs11y.h ykcs11-version.h pinpad-osx.c pinpad-osx.h
 EXTRA_libykcs11_la_DEPENDENCIES = ykcs11.map
 libykcs11_la_LIBADD = ../lib/libykpiv.la ../tool/libpiv_util.la
-libykcs11_la_LDFLAGS = -no-undefined -version-info \
-	$(LT_CURRENT):$(LT_REVISION):$(LT_AGE) $(am__append_1) \
-	$(am__append_2)
+libykcs11_la_LDFLAGS = -no-undefined -framework CoreFoundation \
+	-version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
+	$(am__append_1) $(am__append_2)
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = ykcs11.pc
 @ENABLE_COV_TRUE@AM_LDFLAGS = --coverage
@@ -556,6 +556,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mechanisms.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/objects.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openssl_utils.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pinpad-osx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/slot_vendors.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/token_vendors.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils.Plo@am__quote@
diff -urdN yubico-piv-tool-1.7.0/ykcs11/objects.c yubico-piv-tool-1.7.0.pinpad/ykcs11/objects.c
--- yubico-piv-tool-1.7.0/ykcs11/objects.c	2019-04-03 03:44:44.000000000 -0400
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/objects.c	2019-11-20 21:55:08.111514841 -0500
@@ -624,6 +624,13 @@
 
   case CKA_LABEL:
     DBG("LABEL");
+    if (cert_objects[piv_objects[obj].sub_id].data) {
+      char *name = get_cert_subject_name(cert_objects[piv_objects[obj].sub_id].data);
+      DBG("X509: %s", name);
+      len = strlen(name) + 1;
+      data = (CK_BYTE_PTR) name;
+      break;
+    }
     len = strlen(piv_objects[obj].label) + 1;
     data = (CK_BYTE_PTR) piv_objects[obj].label;
     break;
@@ -865,6 +872,13 @@
 
   case CKA_LABEL:
     DBG("LABEL");
+    if (cert_objects[piv_objects[obj].sub_id].data) {
+      char *name = get_cert_subject_name(cert_objects[piv_objects[obj].sub_id].data);
+      DBG("X509: %s", name);
+      len = strlen(name) + 1;
+      data = (CK_BYTE_PTR) name;
+      break;
+    }
     len = strlen(piv_objects[obj].label) + 1;
     data = (CK_BYTE_PTR) piv_objects[obj].label;
     break;
diff -urdN yubico-piv-tool-1.7.0/ykcs11/openssl_utils.c yubico-piv-tool-1.7.0.pinpad/ykcs11/openssl_utils.c
--- yubico-piv-tool-1.7.0/ykcs11/openssl_utils.c	2018-05-08 03:52:30.000000000 -0400
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/openssl_utils.c	2019-11-20 21:55:08.111514841 -0500
@@ -67,6 +67,15 @@
 
 }
 
+char *get_cert_subject_name(const X509 *cert) {
+  static char namebuf[300] = {};
+  X509_NAME *name = X509_get_subject_name(cert);
+  if (X509_NAME_get_text_by_NID(name, NID_commonName, namebuf, sizeof(namebuf)) > 0) {
+    return namebuf;
+  }
+  return NULL;
+}
+
 CK_RV do_create_empty_cert(CK_BYTE_PTR in, CK_ULONG in_len, CK_BBOOL is_rsa,
                            CK_BYTE_PTR out, CK_ULONG_PTR out_len) {
 
diff -urdN yubico-piv-tool-1.7.0/ykcs11/openssl_utils.h yubico-piv-tool-1.7.0.pinpad/ykcs11/openssl_utils.h
--- yubico-piv-tool-1.7.0/ykcs11/openssl_utils.h	2017-04-06 10:05:57.000000000 -0400
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/openssl_utils.h	2019-11-20 21:55:08.111514841 -0500
@@ -46,6 +46,7 @@
 CK_RV do_get_raw_cert(X509 *cert, CK_BYTE_PTR out, CK_ULONG_PTR out_len);
 CK_RV do_delete_cert(X509 **cert);
 //CK_RV free_cert(X509 *cert);
+char *get_cert_subject_name(const X509 *cert);
 
 CK_RV       do_store_pubk(X509 *cert, EVP_PKEY **key);
 CK_KEY_TYPE do_get_key_type(EVP_PKEY *key);
diff -urdN yubico-piv-tool-1.7.0/ykcs11/pinpad-osx.c yubico-piv-tool-1.7.0.pinpad/ykcs11/pinpad-osx.c
--- yubico-piv-tool-1.7.0/ykcs11/pinpad-osx.c	1969-12-31 19:00:00.000000000 -0500
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/pinpad-osx.c	2019-11-20 21:55:08.111514841 -0500
@@ -0,0 +1,293 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/time.h>
+#include <malloc/malloc.h>
+
+#include <CoreFoundation/CoreFoundation.h>
+
+#include "pinpad-osx.h"
+
+#define dprintf(fmt, args...) fprintf(stderr,"DEBUG %s:%3d: " fmt,__FILE__,__LINE__,##args)
+// #define dprintf(fmt, args...) do {} while (0)
+
+#define MAX_PIN_LEN 8
+
+static inline void cleanup_cfrelease(void *var) {
+	if (*(CFTypeRef *)var != NULL) {
+		CFRelease(*(CFTypeRef *)var);
+	}
+}
+#define AUTORELEASE __attribute__((cleanup(cleanup_cfrelease)))
+
+typedef struct lenbuf {
+	size_t len;
+	char buf[];
+} lenbuf;
+
+static inline void clear_data(lenbuf **buf) {
+	memset((*buf)->buf, 0, (*buf)->len);
+}
+
+#define securebuf lenbuf __attribute__((cleanup(clear_data))) *
+
+#define alloca_buf(sz) ({lenbuf *buf = alloca(sz+sizeof(lenbuf)); if (buf) buf->len = sz; buf;})
+
+static CFUserNotificationRef create_notification(const void** keys, const void** values, int n, CFTimeInterval timeout, CFOptionFlags flags) {
+	SInt32 err;
+	CFDictionaryRef cfNDict = CFDictionaryCreate(NULL, keys, values, n,
+			&kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+
+	CFUserNotificationRef cfNotif = CFUserNotificationCreate(NULL, timeout, flags, &err, cfNDict);
+	return cfNotif;
+}
+
+static CFUserNotificationRef show_message(CFStringRef header, CFStringRef msg, CFTimeInterval timeout) {
+	const void* keys[] = {
+		kCFUserNotificationAlertHeaderKey,
+		kCFUserNotificationAlertMessageKey,
+		kCFUserNotificationDefaultButtonTitleKey,
+	};
+	const void* values[] = {
+		header,
+		msg,
+		CFSTR(""),
+	};
+	CFOptionFlags flags = kCFUserNotificationNoteAlertLevel;
+	return create_notification(keys, values, sizeof(keys)/sizeof(*keys), timeout, flags);
+}
+	
+
+static int show_alert(CFStringRef msg, int waitForOk) {
+	const void* keys[] = {
+		kCFUserNotificationAlertHeaderKey,
+		kCFUserNotificationAlertMessageKey,
+	};
+	const void* values[] = {
+		CFSTR("YubiKey"),
+		msg
+	};
+    
+	CFUserNotificationRef AUTORELEASE cfNotif = create_notification(keys, values, sizeof(keys)/sizeof(*keys), 0, kCFUserNotificationNoteAlertLevel);
+	if (waitForOk) {
+		CFOptionFlags cfRes;
+		CFUserNotificationReceiveResponse(cfNotif, 0, &cfRes);
+	}
+	return 0;
+}
+
+static int get_confirmation(CFStringRef msg) {
+    const void* keys[] = {
+        kCFUserNotificationAlertHeaderKey,
+        kCFUserNotificationAlertMessageKey,
+        kCFUserNotificationAlternateButtonTitleKey,
+    };
+    const void* values[] = {
+        CFSTR("YubiKey"),
+        msg,
+        CFSTR("Cancel"),
+    };
+    
+    CFUserNotificationRef AUTORELEASE cfNotif = create_notification(keys, values, sizeof(keys)/sizeof(*keys), 0, kCFUserNotificationNoteAlertLevel);
+
+    CFOptionFlags cfRes;
+    CFUserNotificationReceiveResponse(cfNotif, 0, &cfRes);
+    return ((cfRes&0x3) == kCFUserNotificationDefaultResponse);
+}
+
+static char *get_pin(CFStringRef msg, CFStringRef prompt, lenbuf *buf) {
+    const void* keys[] = {
+        kCFUserNotificationAlertHeaderKey,
+        kCFUserNotificationAlertMessageKey,
+        kCFUserNotificationAlternateButtonTitleKey,
+        kCFUserNotificationTextFieldTitlesKey,
+    };
+    const void* values[] = {
+        CFSTR("YubiKey"),
+        msg,
+        CFSTR("Cancel"),
+        prompt,
+    };
+    
+    CFUserNotificationRef AUTORELEASE cfNotif = create_notification(keys, values, sizeof(keys)/sizeof(*keys), 0, kCFUserNotificationNoteAlertLevel|CFUserNotificationSecureTextField(0));
+
+    CFOptionFlags cfRes;
+    CFUserNotificationReceiveResponse(cfNotif, 0, &cfRes);
+    if ((cfRes&3) != kCFUserNotificationDefaultResponse) {
+        return NULL;
+    }
+    CFStringRef cfPin = CFUserNotificationGetResponseValue(cfNotif, kCFUserNotificationTextFieldValuesKey, 0);
+    CFStringGetCString(cfPin, buf->buf, buf->len, kCFStringEncodingASCII);
+    return buf->buf;
+}
+
+// static int osx_display_message(struct sc_reader *reader, const char *msg) {
+//     CFStringRef AUTORELEASE cfMsg = CFStringCreateWithCStringNoCopy(NULL, msg, kCFStringEncodingUTF8, kCFAllocatorNull);
+//     return show_alert(cfMsg, 0);
+// }
+
+char *osx_pinpad_get_pin() {
+	CFStringRef AUTORELEASE cfPrompt = NULL, cfErrMsg = CFSTR("");
+	cfPrompt = CFSTR("Enter PIN: ");
+	securebuf pinbuf = alloca_buf(MAX_PIN_LEN);
+	char *pin = NULL;
+	do {
+		pin = get_pin(cfErrMsg, cfPrompt, pinbuf);
+		if (pin == NULL) {
+			dprintf("User did not enter PIN");
+			return NULL;
+		}
+		if (strlen(pin) < 6) {
+			cfErrMsg = CFSTR("PIN too short (must be between 6 and 8 digits)");
+		} else if (strlen(pin) > 8) {
+			cfErrMsg = CFSTR("PIN too long (must be between 6 and 8 digits)");
+		} else if (strspn(pin, "0123456789") != strlen(pin)) {
+			cfErrMsg = CFSTR("PIN must be numeric.");
+		} else {
+			break;
+		}
+	} while (true);
+	return strdup(pin);
+}
+
+static char *key_names[256] = {};
+static int active_key = 0;
+
+typedef struct touch_handler_info {
+	pthread_mutex_t mutex;
+	pthread_cond_t cond;
+	const char *label;
+} touch_handler_info_t;
+
+static void *touch_handler(void *arg) {
+	touch_handler_info_t *info = arg;
+	struct timespec ts;
+	struct timeval tv;
+
+	gettimeofday(&tv, NULL);
+	if (tv.tv_usec >= 500000) {
+		ts.tv_sec = tv.tv_sec + 1;
+		ts.tv_nsec = tv.tv_usec * 1000 - 500000000;
+	} else {
+		ts.tv_sec = tv.tv_sec + 0;
+		ts.tv_nsec = tv.tv_usec * 1000 + 500000000;
+	}
+	dprintf("Starting touch handler thread, curtime %ld.%06d, timeout %ld.%09ld\n", tv.tv_sec, tv.tv_usec, ts.tv_sec, ts.tv_nsec);
+	pthread_mutex_lock(&info->mutex);
+	int retval;
+	if ((retval = pthread_cond_timedwait(&info->cond, &info->mutex, &ts))) {
+		dprintf("Touch token for key: %s (rv %d/%s)\n", info->label, retval, strerror(retval));
+		CFStringRef AUTORELEASE header = info->label
+			? CFStringCreateWithFormat(NULL, NULL, CFSTR("YubiKey: %s"), info->label)
+			: CFStringCreateCopy(NULL, CFSTR("YubiKey"));
+		CFStringRef message = info->label
+			? CFSTR("Touch your YubiKey to use the above key...")
+			: CFSTR("Touch your YubiKey...");
+
+		CFUserNotificationRef AUTORELEASE touch_notification = show_message(header, message, 60);
+		pthread_cond_wait(&info->cond, &info->mutex);
+		dprintf("Cleaning up from touch handler\n");
+		CFUserNotificationCancel(touch_notification);
+	}
+	pthread_mutex_unlock(&info->mutex);
+	return NULL;
+}
+
+// static int (*orig_compute_signature)(struct sc_card *card, const u8 * data,
+// 				 size_t data_len, u8 * out, size_t outlen);
+
+ykpiv_rc osx_pinpad_sign_data(ykpiv_state *state, const unsigned char *sign_in,
+                        size_t in_len, unsigned char *sign_out, size_t *out_len,
+                        unsigned char algorithm, unsigned char key, const char *label) {
+
+// static int osx_compute_signature(struct sc_card *card, const u8 * data, size_t data_len, u8 * out, size_t outlen) {
+	// struct itimerval touch_timeout = {
+	// 	.it_interval = 0,
+	// 	.it_value = {
+	// 		.tv_sec = 0,
+	// 		.tv_usec = 500000,
+	// 	},
+	// };
+	// struct itimerval old_timerval;
+	touch_handler_info_t handler_info = {
+		.mutex = PTHREAD_MUTEX_INITIALIZER,
+		.cond = PTHREAD_COND_INITIALIZER,
+		.label = label,
+	};
+	pthread_t thread;
+
+	// dprintf("in osx_compute_signature, %p %p %d\n", card, data, (int)data_len);
+	dprintf("in osx_pinpad_sign_data, 0x%02x\n", key);
+	dprintf("active key: %s\n", label);
+	pthread_create(&thread, NULL, touch_handler, &handler_info);
+	// notification_allocator = create_zoned_allocator(4096);
+	// void *old_sighandler = signal(SIGALRM, touch_handler);
+	// setitimer(ITIMER_REAL, &touch_timeout, &old_timerval);
+	ykpiv_rc retval = ykpiv_sign_data(state, sign_in, in_len, sign_out, out_len, algorithm, key);
+	// dprintf("finished osx_compute_signature, %p %p %d\n", card, data, (int)data_len);
+	pthread_mutex_lock(&handler_info.mutex);
+	pthread_cond_signal(&handler_info.cond);
+	pthread_mutex_unlock(&handler_info.mutex);
+	pthread_join(thread, NULL);
+	dprintf("touch thread joined\n");
+	// sleep(2);
+	// signal(SIGALRM, old_sighandler);
+	// setitimer(ITIMER_REAL, &old_timerval, NULL);
+	// finish_touch_handler();
+	// destroy_zoned_allocator(notification_allocator);
+	// notification_allocator = NULL;
+	return retval;
+}
+
+// static int (*orig_set_security_env)(struct sc_card *card,
+// 			        const struct sc_security_env *env, int se_num);
+// static int osx_set_security_env(struct sc_card *card, const struct sc_security_env *env, int se_num) {
+// 	dprintf("in osx_set_security_env, %p %p %d\n", card, env, se_num);
+// 	dprintf("senv key: 0x%016llx/%d\n", *(unsigned long long *)env->key_ref, (int)env->key_ref_len);
+// 	unsigned int keyref = *(unsigned long long *)env->key_ref;
+// 	if (keyref < 256) {
+// 		active_key = keyref;
+// 		dprintf("key label: %s\n", key_names[keyref]);
+// 	} else {
+// 		active_key = 0;
+// 	}
+// 	return orig_set_security_env(card, env, se_num);
+// }
+
+// int pinpad_init(sc_pkcs15_card_t *p15card, struct sc_aid *aid, const keyinfo_t *keys, int nkeys) {
+// 	// show_alert(CFSTR("Pinpad initialized"), 1);
+// 	/*
+//     if (get_confirmation(CFSTR("Test PIN get?"))) {
+//         char *pin = get_pin(CFSTR("Testing PIN entry."),CFSTR("PIN:"));
+//         CFStringRef AUTORELEASE pinres = CFStringCreateWithFormat(NULL, NULL, CFSTR("PIN: %s"), pin);
+//         show_alert(pinres, 0);
+//     }
+// 	 */
+//     p15card->card->reader->capabilities |= SC_READER_CAP_PIN_PAD;
+//     p15card->card->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;
+//     p15card->card->reader->driver->ops->display_message = &osx_display_message;
+//     p15card->card->reader->driver->ops->perform_verify = &osx_pin_cmd;
+// 	orig_compute_signature = p15card->card->ops->compute_signature;
+// 	orig_set_security_env = p15card->card->ops->set_security_env;
+// 	p15card->card->ops->compute_signature = &osx_compute_signature;
+// 	p15card->card->ops->set_security_env = &osx_set_security_env;
+//     if (p15card->card->reader->ops != p15card->card->reader->driver->ops) {
+//         static struct sc_reader_operations ops;
+//         memcpy(&ops, p15card->card->reader->ops, sizeof(ops));
+//         ops.display_message = &osx_display_message;
+//         ops.perform_verify = &osx_pin_cmd;
+//         p15card->card->reader->ops = &ops;
+//     }
+// 	for (int k = 0; k < nkeys; k++) {
+// 		int keyref = keys[k].key_reference;
+// 		if (keyref && keyref < 256) {
+// 			if (key_names[keyref]) {
+// 				free(key_names[keyref]);
+// 			}
+// 			key_names[keyref] = strdup(keys[k].pubkey->label);
+// 		}
+// 	}
+// 	return 0;
+// }
diff -urdN yubico-piv-tool-1.7.0/ykcs11/pinpad-osx.h yubico-piv-tool-1.7.0.pinpad/ykcs11/pinpad-osx.h
--- yubico-piv-tool-1.7.0/ykcs11/pinpad-osx.h	1969-12-31 19:00:00.000000000 -0500
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/pinpad-osx.h	2019-11-20 21:55:08.111514841 -0500
@@ -0,0 +1,11 @@
+#ifndef PINPAD_OSX_H
+#define PINPAD_OSX_H
+
+#include "ykpiv.h"
+
+char *osx_pinpad_get_pin();
+ykpiv_rc osx_pinpad_sign_data(ykpiv_state *state, const unsigned char *sign_in,
+                        size_t in_len, unsigned char *sign_out, size_t *out_len,
+                        unsigned char algorithm, unsigned char key, const char *label);
+
+#endif
\ No newline at end of file
diff -urdN yubico-piv-tool-1.7.0/ykcs11/ykcs11.c yubico-piv-tool-1.7.0.pinpad/ykcs11/ykcs11.c
--- yubico-piv-tool-1.7.0/ykcs11/ykcs11.c	2019-04-03 03:44:44.000000000 -0400
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/ykcs11.c	2019-11-20 21:55:08.111514841 -0500
@@ -40,6 +40,7 @@
 #include "openssl_types.h"
 #include "openssl_utils.h"
 #include "debug.h"
+#include "pinpad-osx.h"
 
 #include <stdbool.h>
 #include "../tool/util.h"
@@ -767,6 +768,15 @@
   return CKR_FUNCTION_FAILED;
 }
 
+static inline void clear_string(char **str) {
+  if (*str) {
+    memset(*str, 0, strlen(*str));
+  }
+}
+
+#define securebuf lenbuf __attribute__((cleanup(clear_data))) *
+
+
 CK_DEFINE_FUNCTION(CK_RV, C_Login)(
   CK_SESSION_HANDLE hSession,
   CK_USER_TYPE userType,
@@ -777,6 +787,8 @@
   DIN;
   CK_RV          rv;
   token_vendor_t token;
+  int using_pinpad = 0;
+  char __attribute__((cleanup(clear_string))) *gotpin = NULL;
 
   if (piv_state == NULL) {
     DBG("libykpiv is not initialized or already finalized");
@@ -789,6 +801,18 @@
     return CKR_USER_TYPE_INVALID;
 
   DBG("user %lu, pin %s, pinlen %lu", userType, pPin, ulPinLen);
+  if (pPin && !strcmp((char *)pPin, "pinpad")) {
+    if (userType == CKU_CONTEXT_SPECIFIC) {
+      gotpin = osx_pinpad_get_pin();
+      if (gotpin) {
+        pPin = (CK_UTF8CHAR_PTR) gotpin;
+        ulPinLen = strlen(gotpin);
+        DBG("from pinpad: pin %s, pinlen %lu", pPin, ulPinLen);
+      }
+    } else {
+      using_pinpad = userType;
+    }
+  }
 
   if (session.handle != YKCS11_SESSION_ID) {
     DBG("Session is not open");
@@ -822,11 +846,14 @@
       return CKR_USER_ANOTHER_ALREADY_LOGGED_IN;
     }
 
-    rv = token.token_login(piv_state, CKU_USER, pPin, ulPinLen);
-    if (rv != CKR_OK) {
-      DBG("Unable to login as regular user");
-      return rv;
+    if (!using_pinpad) {
+      rv = token.token_login(piv_state, CKU_USER, pPin, ulPinLen);
+      if (rv != CKR_OK) {
+        DBG("Unable to login as regular user");
+        return rv;
+      }
     }
+    session.using_pinpad = using_pinpad;
 
     if ((session.info.flags & CKF_RW_SESSION) == 0)
       session.info.state = CKS_RO_USER_FUNCTIONS;
@@ -845,11 +872,14 @@
         session.info.state == CKS_RW_USER_FUNCTIONS)
       return CKR_USER_ANOTHER_ALREADY_LOGGED_IN;
 
-    rv = token.token_login(piv_state, CKU_SO, pPin, ulPinLen);
-    if (rv != CKR_OK) {
-      DBG("Unable to login as SO");
-      return rv;
+    if (!using_pinpad) {
+      rv = token.token_login(piv_state, CKU_SO, pPin, ulPinLen);
+      if (rv != CKR_OK) {
+        DBG("Unable to login as SO");
+        return rv;
+      }
     }
+    session.using_pinpad = using_pinpad;
 
     session.info.state = CKS_RW_SO_FUNCTIONS;
     break;
@@ -896,6 +926,7 @@
     return CKR_SESSION_HANDLE_INVALID;
   }
 
+  session.using_pinpad = 0;
   if (session.info.state == CKS_RO_PUBLIC_SESSION ||
       session.info.state == CKS_RW_PUBLIC_SESSION)
     return CKR_USER_NOT_LOGGED_IN;
@@ -1696,12 +1727,15 @@
   CK_ULONG     key_len = 0;
   CK_BYTE      exp[3];
   CK_BYTE      buf[1024] = {0};
+  static CK_BYTE label[300] = {0};
+  CK_RV        rv;
   CK_ATTRIBUTE template[] = {
     {CKA_KEY_TYPE, &type, sizeof(type)},
     {CKA_MODULUS_BITS, &key_len, sizeof(key_len)},
     {CKA_MODULUS, NULL, 0},
     {CKA_PUBLIC_EXPONENT, exp, sizeof(exp)},
     {CKA_EC_POINT, buf, sizeof(buf)},
+    {CKA_LABEL, label, sizeof(label)},
   };
 
   DIN;
@@ -1731,6 +1765,22 @@
 
   DBG("Trying to sign some data with mechanism %lu and key %lu", pMechanism->mechanism, hKey);
 
+  if (session.using_pinpad) {
+    DBG("PIN auth delayed until use, asking user...");
+    token_vendor_t token = get_token_vendor(session.slot->token->vid);
+    char __attribute__((cleanup(clear_string))) *gotpin = NULL;
+
+    gotpin = osx_pinpad_get_pin();
+    if (gotpin) {
+      rv = token.token_login(piv_state, session.using_pinpad, (CK_UTF8CHAR_PTR)gotpin, strlen(gotpin));
+
+      if (rv == CKR_OK) {
+        session.using_pinpad = 0;
+      }
+    }
+
+  }
+
   // Check if mechanism is supported
   if (check_sign_mechanism(&session, pMechanism) != CKR_OK) {
     DBG("Mechanism %lu is not supported either by the token or the module", pMechanism->mechanism);
@@ -1810,6 +1860,11 @@
     DBG("Incorrect key %lu", hKey);
     return CKR_KEY_HANDLE_INVALID;
   }
+  op_info.op.sign.key_label = NULL;
+  if (get_attribute(&session, hKey, template + 5) == CKR_OK) {
+    DBG("Key label is %s", label);
+    op_info.op.sign.key_label = (char *)label;
+  }
 
   DBG("Algorithm is %d", op_info.op.sign.algo);
   // Make sure that both mechanism and key have the same algorithm
@@ -1936,7 +1991,7 @@
 
   *pulSignatureLen = sizeof(op_info.buf);
 
-  piv_rv = ykpiv_sign_data(piv_state, op_info.buf, op_info.buf_len, op_info.buf, pulSignatureLen, op_info.op.sign.algo, op_info.op.sign.key_id);
+  piv_rv = osx_pinpad_sign_data(piv_state, op_info.buf, op_info.buf_len, op_info.buf, pulSignatureLen, op_info.op.sign.algo, op_info.op.sign.key_id, op_info.op.sign.key_label);
   if (piv_rv != YKPIV_OK) {
     if (piv_rv == YKPIV_AUTHENTICATION_ERROR) {
       DBG("Operation requires authentication or touch");
diff -urdN yubico-piv-tool-1.7.0/ykcs11/ykcs11.h yubico-piv-tool-1.7.0.pinpad/ykcs11/ykcs11.h
--- yubico-piv-tool-1.7.0/ykcs11/ykcs11.h	2017-04-06 10:05:57.000000000 -0400
+++ yubico-piv-tool-1.7.0.pinpad/ykcs11/ykcs11.h	2019-11-20 21:55:08.111514841 -0500
@@ -55,6 +55,7 @@
 typedef struct {
   CK_SESSION_HANDLE handle;
   CK_SESSION_INFO   info; /* slotid, state, flags, deviceerror */
+  int               using_pinpad;
   ykcs11_slot_t     *slot;
 } ykcs11_session_t;
 
@@ -79,6 +80,7 @@
   CK_BYTE           algo;    // Algo for ykpiv // TODO: infer this from the key length?
   CK_ULONG          key_id;  // Key id for ykpiv // TODO: make this a BYTE and store the id {0, 1, 2, 3}
   CK_ULONG          key_len; // Length in bits
+  char              *key_label;
 } sign_info_t;
 
 typedef struct {
